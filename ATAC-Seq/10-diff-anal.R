#!/usr/bin/env Rscript

############################################################################
#   CNC-EMDiff differential peak analysis
#   Jason W. Bacon
#   Spring, 2020
#
#   Based on OpticRegen by Andrea Rau
#   https://github.com/andreamrau/OpticRegen_2019
#   Thanks to Paul Auer for extensive guidance
############################################################################

# Choose CCA for chondro or NCA for neuro
args <- commandArgs(trailingOnly=TRUE)
if ( (length(args) != 1) || ((args[1] != "CCA") && (args[1] != "NCA")) )
{
    print("Usage: RScript diff-anal.R CCA|NCA")
    stop()
}
cell_type <- args[1]

# Compensate for misnamed sequence files.
flip_rep_and_cond <- TRUE

# Process MACS2 peaks.  If FALSE, use peaks processed externally using
# bedtools instead. If you change this, you must rerun dba() and dba.count().
# Remove <cell_type>-readcounts_pvalsort.RData to make this happen.
process_peaks_in_R <- FALSE

# Loading libraries takes 20 seconds or more
library(DiffBind)
library(dplyr)
library(DESeq2)
library(GenomicRanges)
library(RColorBrewer)
library(pheatmap)

# Pause until user presses enter
pause <- function()
{
    if ( FALSE )
    {
	cat("Press Enter to continue...")
	invisible(b <- scan("stdin", character(), nlines=1, quiet=TRUE))
    }
}

# Prevent print() from spewing huge tables to stdout
options(max.print=60)

# Make all output group-writable
Sys.umask(mode = 007)

# Generate merged peaks file
if ( process_peaks_in_R )
{
    macsBed <- read.delim(paste0("7-macs-peaklets/ATAC-", cell_type,
	"-macs.peaklets_peaks.narrowPeak"), header=FALSE)
    ## Sort by p-value ($V8), only keep those with p-value < 10^-10 [44429]
    # keep - index vector
    # Done using awk
    
    # V8 = p-value.  Could use q-value as well.
    keep <- which(macsBed$V8 > -log(10^-10))
    #print("keep (rows where p < 10^-10)")
    #print(keep)
    
    # new table, keep rows in "keep"
    macs_all <- macsBed[keep,]
    # print("macs_all (peaks with p < 10^-10)")
    # print(macs_all)
    
    # debug: How many rows were filtered out?
    cat(nrow(macsBed), "...", nrow(macs_all), "\n")
    
    ## And write out merged : AR modified to use 501 bp regions
    # like bedtools - make peaklet around summit
    # col 2 = start, col 10 = distance from start to peak
    macs_all_GR <- GRanges(seqnames=as.vector(macs_all[,1]),
			   IRanges(start=as.numeric(as.vector(macs_all[,2])) + 
				   as.numeric(as.vector(macs_all[,10])) - 250,
				   end=as.numeric(as.vector(macs_all[,2])) + 
				   as.numeric(as.vector(macs_all[,10])) + 250),
				   strand=rep("*", nrow(macs_all)))
    print("max_all_GR: 501 nt generated peaks")
    print(macs_all_GR)
    # line <- readline(prompt="Press [enter] to continue")
    pause()
    
    # add metadata to table
    # Remove columns 1-3
    elementMetadata(macs_all_GR) <- macs_all[,-c(1:3)]
    
    # Add names for each col
    colnames(elementMetadata(macs_all_GR)) <- c("Peak_ID","Score","Strand", 
						"Fold-change", "log10pvalue",
						"log10qvalue",
						"Relative_summit")
    
    ## Note: we have a very small number (~50) of overlapping peaklets, I have just left
    ## them as is without merging (so we may be double counting a small number of reads)
    
    # merge overlapping peaks
    # Done with bedtools merge
    macsGR_bed <- data.frame(chr=seqnames(macs_all_GR),
			     starts=start(macs_all_GR),
			     end=end(macs_all_GR),
			     names=c(rep(".", length(macs_all_GR))),
			     scores=c(rep(".", length(macs_all_GR))),
			     strands=strand(macs_all_GR))
    
    ## Note: some of the peaks need to be recentered (negative start)
    index <- which(macsGR_bed$starts < 1)
    macsGR_bed[index, "end"] <- macsGR_bed[index, "end"] - macsGR_bed[index, "starts"] + 1
    macsGR_bed[index, "starts"] <- 1
    ## Note: some of the peaks need to be recentered (too long)
    # This look useless for CNC-EMDiff.  What was it for in OpticRegen?
    #index <- which(macsGR_bed$chr == "KN149934.1" & macsGR_bed$end == 12555)
    #macsGR_bed[index, "end"] <- 12451; macsGR_bed[index, "starts"] <- macsGR_bed[index, "end"] - 499
    #index <- which(macsGR_bed$chr == "KN149962.1" & macsGR_bed$end == 136196)
    #macsGR_bed[index, "end"] <- 136181; macsGR_bed[index, "starts"] <- macsGR_bed[index, "end"] - 499
    #index <- which(macsGR_bed$chr == "KN150281.1" & macsGR_bed$end == 3781)
    #macsGR_bed[index, "end"] <- 3763; macsGR_bed[index, "starts"] <- macsGR_bed[index, "end"] - 499
    #index <- which(macsGR_bed$chr == "KN150391.1" & macsGR_bed$end == 26616)
    #macsGR_bed[index, "end"] <- 26543; macsGR_bed[index, "starts"] <- macsGR_bed[index, "end"] - 499
    #write.table(macsGR_bed, paste0("PEAKS_TRANS_PEAKLETS_ALLTIMES/",
    # "ALLMERGED_ATAC.nodup.unique.macs.peaklets_peaks.pvalsort.narrowPeak_501bp.bed")
    write.table(macsGR_bed, paste0(cell_type, "-R-code-merged-peaks.bed"),
		col.names=FALSE, row.names=FALSE, quote=FALSE, sep="\t")
    
    # Merged peaks generated by R code above
    Peaks <- paste0(cell_type, "-R-code-merged-peaks.bed")
    
    print("macsGR_bed: Merged peaks")
    print(macsGR_bed)
    pause()
} else {
    # Generated externally using bedtools
    Peaks <- paste0("7-macs-peaklets/high-confidence-p10-",
		    cell_type, "-501-merged.bed")
}

print("Peaks")
print(Peaks)

## Read in peaksets, identify consensus
# %>% = pipe
# Example CNC-EMDiff filename: CCA1A_S1_L001-nodup-uniq.bam
# "1A": 1 = condition, A = time point
# SampleID <- strsplit(dir("ALIGNED_TRANS/"), split=".", fixed=TRUE) %>%
# Could this just as well use the merged BAMs in 8-?
SampleID <- strsplit(dir("4-bwa-mem/", pattern=paste0(cell_type, ".*.bam")),
  split=".", fixed=TRUE) %>% lapply(., function(x) x[1]) %>%
  unlist() %>% unique()

print("SampleID")
print(SampleID)

if ( flip_rep_and_cond )
{
    Condition <- substr(SampleID, 4, 4) %>% unlist()    # Flip condition/replicate
} else {
    Condition <- substr(SampleID, 5, 5) %>% unlist()
}

print("Condition")
print(Condition)

if ( flip_rep_and_cond )
{
    Replicate <- substr(SampleID, 5, 5)%>% unlist()     # Flip condition/replicate
} else {
    Replicate <- substr(SampleID, 4, 4)%>% unlist()
}

print("Replicate")
print(Replicate)
pause()

# Select only .bam files
bamReads <- paste0("4-bwa-mem/",
		   dir("4-bwa-mem/", pattern=paste0(cell_type, ".*.bam$")))

print("bamReads")
print(bamReads)

# rep = repeat
PeakCaller <- rep("narrow", length(SampleID))
print("PeakCaller")
print(PeakCaller)
pause()

# Create new table from existing vectors
samples <- data.frame(SampleID, Condition, Replicate, bamReads, Peaks, PeakCaller)
print("samples")
print(samples)
pause()

readcounts_filename <- paste0(cell_type, "-readcounts_pvalsort.RData")
if ( file.exists(readcounts_filename) ) {
    print("Using saved dba.count() results...")
    print(paste("Remove ", readcounts_filename,
	" before running this script if anything has changed"))
    load(readcounts_filename)
} else {
    print("Running dba(sampleSheet=samples)")
    start_time <- Sys.time()
    peaksets_pvalsort <- dba(sampleSheet=samples)
    end_time <- Sys.time()
    print("dba() time:")
    print(end_time - start_time)
    
    # Debug
    pdf(paste0("peaksets-pvalsort-overall-clustering-", cell_type, ".pdf"))
    plot(peaksets_pvalsort)
    dev.off()   # close() pdf
    
    ## Count overlapping reads (did not recenter around peaks)
    # Count bam pileups over peaks
    # dba.count() takes a long time so use saved results if available
    # Remove the file before running this script if anything has changed
    print("Running dba.count(peaksets_pvalsort)")
    start_time <- Sys.time()
    readcounts_pvalsort <- dba.count(peaksets_pvalsort)
    end_time <- Sys.time()
    print("dba.count() time:")
    print(end_time - start_time)
    
    # debug
    pdf(paste0("readcounts-pvalsort-overall-clustering-", cell_type, ".pdf"))
    plot(readcounts_pvalsort)
    dev.off()
    
    # Save this one object from the session
    save(list="readcounts_pvalsort", file=readcounts_filename)
    #save(list=c("samples", "readcounts_pvalsort"), file="sampledata.RData")
}

print("readcounts_pvalsort:")
print(readcounts_pvalsort)
pause()

# Does not work: "Cannot coerc" error
# write.table(readcounts_pvalsort, file="readcounts_pvalsort.table",
#            quote=FALSE, sep="\t")

## Differential analysis (DESeq2) comparing all time points to 0
# colData <- samples is sufficient here
colData <- data.frame(samples)
print("colData:")
print(colData)
pause()

# Extract data we really need
# [[]] means list
rowData_pvalsort <- readcounts_pvalsort$peaks[[1]][,1:3]
print("rowData_pvalsort:")
print(rowData_pvalsort)
pause()

# Get read counts for all peaks
# Organize as a table with each sample as a column
counts_pvalsort <- lapply(readcounts_pvalsort$peaks, function(x) x$Reads) %>%
  do.call("cbind", .)

# Recode X variable as a numeric indicator variable
# factor level variable instead of character for regression
colData$time_factor <- factor(colData$Condition)
print("colData$time_factor:")
print(colData$time_factor)
pause()

# Organize input
dds_pvalsort <- DESeqDataSetFromMatrix(countData = counts_pvalsort,
				       colData = colData,
				       rowRanges = GRanges(rowData_pvalsort),
				       design = ~ time_factor)

# pauer 2020-03-16
vsd <- vst(dds_pvalsort, blind=FALSE)
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$SampleID)
colnames(sampleDistMatrix) <- paste(vsd$SampleID)
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pdf(paste0("heatmap-Sample-Similarity-", cell_type, ".pdf"),
    height=8, width=11)
pheatmap(sampleDistMatrix,
	 clustering_distance_rows=sampleDists,
	 clustering_distance_cols=sampleDists,
	 col=colors)
dev.off()

# Run differential analysis
print("Running DESeq...")
dds_pvalsort <- DESeq(dds_pvalsort)
print("dds_pvalsort:")
print(dds_pvalsort)
pause()

# Generate data for Excel file

# According to file naming conventions.  Does not work: Almost no differential
# peaks.  Are we comparing replicates rather than time points due to a sample
# mixup?
if ( flip_rep_and_cond )
{
    # Flip condition/replicate
    res_pvalsort_BvsA <- results(dds_pvalsort, contrast = c("time_factor", "2", "1"))
    res_pvalsort_CvsA <- results(dds_pvalsort, contrast = c("time_factor", "3", "1"))
    res_pvalsort_CvsB <- results(dds_pvalsort, contrast = c("time_factor", "3", "2"))
} else {
    res_pvalsort_BvsA <- results(dds_pvalsort, contrast = c("time_factor", "B", "A"))
    res_pvalsort_CvsA <- results(dds_pvalsort, contrast = c("time_factor", "C", "A"))
    res_pvalsort_CvsB <- results(dds_pvalsort, contrast = c("time_factor", "C", "B"))
}

print(paste0(cell_type, " day 2 vs day 0"))
summary(res_pvalsort_BvsA, alpha=0.05) ## Previously 104

print(paste0(cell_type, " day 6 vs day 0"))
summary(res_pvalsort_CvsA, alpha=0.05) ## Previously 0

print(paste0(cell_type, " day 6 vs day 2"))
summary(res_pvalsort_CvsB, alpha=0.05)
stop()

# Andrea's OpticRegen code below
# Create CSVs with differentially accessible peaks
## No differential peaks at 7 to 0
for(i in c(2,4,12)) {
  res_pvalsort <- get(paste0("res_pvalsort_", i, "vs0"))
  sigpeaks_pvalsort <- data.frame(rowRanges(dds_pvalsort[which(get(paste0("res_pvalsort_", i, "vs0"))$padj < 0.05),])[,1:2],
				    get(paste0("res_pvalsort_", i, "vs0"))[which(get(paste0("res_pvalsort_", i, "vs0"))$padj < 0.05),])
  o <- order(abs(sigpeaks_pvalsort$log2FoldChange), decreasing=TRUE)
  sigpeaks_pvalsort_order <- sigpeaks_pvalsort[o,]
    sigpeaks_pvalsort_order$new_seqnames <- paste0(sigpeaks_pvalsort_order$seqnames,
						 ":", sigpeaks_pvalsort_order$start,
						 "-", sigpeaks_pvalsort_order$end)
  allpeaks_pvalsort <- data.frame(rowRanges(dds_pvalsort)[,1:2],
				  get(paste0("res_pvalsort_", i, "vs0")))
  allpeaks_pvalsort$new_seqnames <- paste0(allpeaks_pvalsort$seqnames,
					   ":", allpeaks_pvalsort$start,
					   "-", allpeaks_pvalsort$end)
  saveRDS(sigpeaks_pvalsort_order, paste0("DIFFERENTIAL_vs0/sigpeaks_pvalsort_order_", i, "vs0_peaklets_501bp.rds"))
  saveRDS(allpeaks_pvalsort, paste0("DIFFERENTIAL_vs0/allpeaks_pvalsort_", i, "vs0_peaklets_501bp.rds"))
    saveRDS(res_pvalsort, paste0("DIFFERENTIAL_vs0/res_pvalsort_", i, "vs0_peaklets_501bp.rds"))
  write.csv(sigpeaks_pvalsort_order, paste0("DIFFERENTIAL_vs0/res_pvalsort_", i, "vs0_peaklets_501bp.csv"))
}


saveRDS(dds_pvalsort, "DIFFERENTIAL_vs0/dds_pvalsort_peaklets_501bp.rds")
save.image("DIFFERENTIAL_vs0/differential-analysis_diffBind_pvalsort_trans_peaklets_501bp.RData")

# peaks opening or closing from time 0
## Count number of overall differential / nondifferential
tmp <- cbind(res_pvalsort_2vs0$padj, res_pvalsort_4vs0$padj,
	     res_pvalsort_7vs0$padj, res_pvalsort_12vs0$padj)
tmp2 <- cbind(res_pvalsort_2vs0$log2FoldChange, res_pvalsort_4vs0$log2FoldChange,
	     res_pvalsort_7vs0$log2FoldChange, res_pvalsort_12vs0$log2FoldChange)
tmp <- tmp < 0.05
tmp[is.na(tmp)] <- 0
table(rowSums(tmp))

## Count number of open/closed differential peaks
colSums((tmp2 < 0) * tmp)
colSums((tmp2 > 0) * tmp)
colSums(tmp)

table(rowSums((tmp2 < 0) * tmp))
table(rowSums((tmp2 > 0) * tmp))

tmp <- cbind(res_pvalsort_2vs0$padj, res_pvalsort_4vs0$padj,
	     res_pvalsort_7vs0$padj, res_pvalsort_12vs0$padj)
tmp[is.na(tmp)] <- 1
tmp2 <- cbind(res_pvalsort_2vs0$log2FoldChange, res_pvalsort_4vs0$log2FoldChange,
	      res_pvalsort_7vs0$log2FoldChange, res_pvalsort_12vs0$log2FoldChange)
tmp[c(11499, 11719),]
tmp2[c(11499, 11719),]
rowData_pvalsort[c(11499, 11719),]


#-----------------------------------------------------
## Output bed files of differential ATAC peaks

tmp_all <- data.frame(chr=character(), start=numeric(), end=numeric(),
		      stringsAsFactors = FALSE)
for(i in c(2,4,12)) {
  tmp <- readRDS(paste0("DIFFERENTIAL_vs0/sigpeaks_pvalsort_order_", i, 
			"vs0_peaklets_501bp.rds"))
  tmp_bed <- tmp %>%
    select(chr=seqnames, start, end)
  write.table(tmp_bed, file = paste0("DIFFERENTIAL_vs0/sigpeaks_", i, 
				     "vs0_peaklets_501bp.bed"),
	      row.names=FALSE, col.names=FALSE, quote=FALSE)
  tmp_all <- bind_rows(tmp_all, tmp_bed)
}

tmp_all <- unique(tmp_all)
write.table(tmp_all, file = paste0("DIFFERENTIAL_vs0/sigpeaks_all_peaklets_501bp.bed"),
	    row.names=FALSE, col.names=FALSE, quote=FALSE)


#-----------------------------------------------------
## Output bed files of directional differential ATAC peaks


for(i in c(2,12)) {
      tmp <- readRDS(paste0("DIFFERENTIAL_vs0/sigpeaks_pvalsort_order_", i, 
			"vs0_peaklets_501bp.rds"))
  for(type in c("up", "down")) {
    tmp_bed <- tmp %>%
      mutate(sign = ifelse(log2FoldChange > 0, "up", "down")) %>%
      filter(sign == type) %>%
      select(chr=seqnames, start, end)
    print(dim(tmp_bed))
    write.table(tmp_bed, file = paste0("DIFFERENTIAL_vs0/sigpeaks_", i, 
				       "vs0_peaklets_501bp_", type, ".bed"),
		row.names=FALSE, col.names=FALSE, quote=FALSE, sep="\t")
  }

}


tmp_2 <- readRDS(paste0("DIFFERENTIAL_vs0/sigpeaks_pvalsort_order_", 2, 
			"vs0_peaklets_501bp.rds")) %>%
  select(new_seqnames) %>% unlist()
tmp_12 <- readRDS(paste0("DIFFERENTIAL_vs0/sigpeaks_pvalsort_order_", 12, 
			"vs0_peaklets_501bp.rds")) %>%
  select(new_seqnames) %>% unlist()
tmp <- c(tmp_2, tmp_12)
tmp[duplicated(tmp)]

